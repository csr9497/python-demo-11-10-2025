name: Setup AWS and Deploy CloudFormation Stack
on:
  push:
    paths:
      - .github/workflows/* 
jobs:
  aws-setup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }} 

      - name: Check if Key Pair exists
        id: check_keypair
        run: |
          set -e
          if aws ec2 describe-key-pairs --key-names AuroraBastionKey; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT 
          fi

      - name: Create AWS Key Pair
        if: steps.check_keypair.outputs.exists == 'false'
        run: |
          aws ec2 create-key-pair --key-name AuroraBastionKey --query 'KeyMaterial' --output text > AuroraBastionKey.pem
          # Opcional: guardar el archivo como artifact
          
      - name: Upload PEM as artifact
        uses: actions/upload-artifact@v4
        with:
          name: bastion-key
          path: AuroraBastionKey.pem
      
      - name: Set Name Stacks
        run: | 
          echo "RUN_ID=demo-stack-devops-$(date +%Y%m%d%H%M%S)" >> $GITHUB_ENV

      - name: Deploy CloudFormation stack
        run: |
          aws cloudformation deploy \
            --template-file Iac/cloudFormationStack.yaml \
            --stack-name $RUN_ID \
            --parameter-overrides KeyName=AuroraBastionKey AvailabilityZones=us-east-2a,us-east-2b 

      - name: Get Aurora Secret ARN
        run: |
          secret_arn=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='SecretArn'].OutputValue" \
            --output text)
          echo "SECRET_ARN=$secret_arn" >> $GITHUB_ENV

      - name: Get Aurora endpoint
        run: |
          endpoint=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='ClusterEndpoint'].OutputValue" \
            --output text)
          echo "ENDPOINT_RDS_AURORA=$endpoint" >> $GITHUB_ENV

      - name: Get VPC 
        run: |
          vpcid=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='VpcId'].OutputValue" \
            --output text)
          echo "VPC_ID=$vpcid" >> $GITHUB_ENV

      - name: Get Security Group ID for Lambda Configuration
        run: |
          SecurityGroup=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='DBSecurityGroupLambda'].OutputValue" \
            --output text)
          echo "SECURITY_GROUP=$SecurityGroup" >> $GITHUB_ENV

      - name: Get Bastion endpoint
        run: |
          ip_bastion=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='BastionPublicIP'].OutputValue" \
            --output text)
          echo "IP_BASTION=$ip_bastion" >> $GITHUB_ENV

      - name: Get Aurora password
        run: |
          password=$(aws secretsmanager get-secret-value \
            --secret-id $SECRET_ARN \
            --query 'SecretString' --output text | jq -r '.password')
          echo "PASSWORD=$password" >> $GITHUB_ENV

      - name: Get DB NAME 
        run: |
          db_name=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='DBName'].OutputValue" \
            --output text)
          echo "DBName=$db_name" >> $GITHUB_ENV


      - name: Get DB NAME
        run: |
          subnets=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='PrivateSubnets'].OutputValue" \
            --output text)
          echo "SUBNETIDS=$subnets" >> $GITHUB_ENV

      - name: Genera archivo de variables (ejemplo JSON)
        run: |
          echo "{
            \"VPC\": \"$VPC_ID\",
            \"HOST\": \"$ENDPOINT_RDS_AURORA\",
            \"USER\": \"$AURORA_USER\",
            \"PASSWORD\": \"$PASSWORD\",
            \"IP_BASTION\": \"$IP_BASTION\",
            \"SECURITY_GROUP\": \"$SECURITY_GROUP\",
            \"DBName\": \"$DBName\",
            \"SUBNETIDS\": \"$SUBNETIDS\"
          }" > mensaje.json

      - name: Subir artifact
        uses: actions/upload-artifact@v4
        with:
          name: mensaje-params
          path: mensaje.json

      # - name: Tunnel SSH to Aurora (in background)
      #   run: |
      #     nohup ssh -i AuroraBastionKey.pem -N -L \
      #      3307:$ENDPOINT_RDS_AURORA:3306 \
      #       ubuntu@$IP_BASTION &

      # - name: Run SQL initialization script
      #   run: |
      #     mysql -h $ENDPOINT_RDS_AURORA -u $AURORA_USER -p $PASSWORD < SQL/user.sql

  deploy-lambda:
    runs-on: ubuntu-latest 
    needs: aws-setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }} 

      - name: Use Node.js 
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install TypeScript globally
        run: npm install -g typescript

      - name : Install JS dependencies
        run: |
           npm install

      - name: Zip Lambda function
        run: |
          mkdir lambdas-zipped
          cd lambdas-two
          for d in */ ; do
            ./${d}build.sh $d
          done


      - name: Create S3 bucket (if not exists) 
        env:
          AWS_S3_BUCKET: ${{ secrets.LAMBDA_ARTIFACT_BUCKET }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }} 
        run: |
          if aws s3api head-bucket --bucket "$AWS_S3_BUCKET" 2>/dev/null; then
            echo "Bucket $AWS_S3_BUCKET already exists."
          else
            aws s3api create-bucket --bucket "$AWS_S3_BUCKET" --region "$AWS_REGION" \
              --create-bucket-configuration LocationConstraint="$AWS_REGION"
            echo "Bucket $AWS_S3_BUCKET created."
          fi

      - name: Upload zip to S3
        uses: jakejarvis/s3-sync-action@v0.5.1
        with:
          args: --acl private
        env:
          AWS_S3_BUCKET: ${{ secrets.LAMBDA_ARTIFACT_BUCKET }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          SOURCE_DIR: ./lambdas-zipped          # Root (will look for lambda.zip)
          DEST_DIR: lambda-artifacts

      - name: Descargar artifact
        uses: actions/download-artifact@v4
        with:
          name: mensaje-params
          path: mensaje.json

      - name: Leer archivo de variables
        run: |
          for key in $(jq -r 'keys[]' mensaje.json); do
            value=$(jq -r --arg k "$key" '.[$k]' mensaje.json)
            echo "$key=$value" >> $GITHUB_ENV
          done

            # Prueba: mostrar variables ya exportadas
            echo "HOST: $HOST"
            echo "USER: $USER"
            echo "PASSWORD: $PASSWORD"
            echo "DATABASE: $DATABASE"
            echo "SECURITY_GROUP: $SECURITY_GROUP"
            echo "SUBNETIDS: $SUBNETIDS"

      - name: Create Lambda functions and API GatewayId
        run: |
          aws cloudformation deploy \
            --template-file Iac/api.yaml \
            --stack-name lambda-api-stack-$(date +%Y%m%d%H%M%S) \
            --parameter-overrides AWSS3BUCKET=${{ secrets.LAMBDA_ARTIFACT_BUCKET }} HOST=$HOST USER=$USER PASSWORD=$PASSWORD DATABASE=$DATABASE SECURITY_GROUP=$SECURITY_GROUP SUBNETIDS=$SUBNETIDS  \
            --capabilities CAPABILITY_NAMED_IAM

  test-lambdas:
    runs-on: ubuntu-latest 
    needs: deploy-lambda
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }} 

      - name: Ejecuta tests de Lambda desde archivos
        run: |
          for testfile in lambda-tests/*.json; do
            FUNC_NAME=$(basename "$testfile" .json)
            echo "Probando funciÃ³n $FUNC_NAME con payload de $testfile"
            aws lambda invoke \
              --function-name "$FUNC_NAME" \
              --payload file://"$testfile" \
              "output_$FUNC_NAME.json"
            echo "Output de $FUNC_NAME:"
            cat "output_$FUNC_NAME.json"
            echo ""
          done

  test-apai:
    runs-on: ubuntu-latest
    needs: test-lambdas
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }} 

      - name: Ejecuta tests de la API (curl) desde archivos
        env:
          BASE_URL: ${{ github.event.inputs.api_base_url }}
        run: |
          for testfile in api-tests/*.json; do
            TEST=$(cat "$testfile")
            ENDPOINT=$(echo "$TEST" | jq -r .path)
            METHOD=$(echo "$TEST" | jq -r .method)
            BODY=$(echo "$TEST" | jq -c .body)
            OUT_FILE="output_$(basename "$testfile" .json).txt"
            
            echo "Test: $testfile ($METHOD $ENDPOINT)"
            
            if [ "$BODY" != "null" ]; then
              curl -X "$METHOD" "$BASE_URL$ENDPOINT" -H "Content-Type: application/json" -d "$BODY" -s -w "\n" > "$OUT_FILE"
            else
              curl -X "$METHOD" "$BASE_URL$ENDPOINT" -s -w "\n" > "$OUT_FILE"
            fi

            echo "Respuesta:"
            cat "$OUT_FILE"
            echo ""
          done