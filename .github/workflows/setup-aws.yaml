name: Setup AWS and Deploy CloudFormation Stack
on:
  push:
    branches:
      - main
      - develop
jobs:
  aws-setup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }} 

      - name: Check if Key Pair exists
        id: check_keypair
        run: |
          set -e
          if aws ec2 describe-key-pairs --key-names AuroraBastionKey; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT 
          fi

      - name: Create AWS Key Pair
        if: steps.check_keypair.outputs.exists == 'false'
        run: |
          aws ec2 create-key-pair --key-name AuroraBastionKey --query 'KeyMaterial' --output text > AuroraBastionKey.pem
          # Opcional: guardar el archivo como artifact
          
      - name: Upload PEM as artifact
        uses: actions/upload-artifact@v4
        with:
          name: bastion-key
          path: AuroraBastionKey.pem
      
      - name: Set Name Stacks
        run: | 
          echo "RUN_ID=demo-stack-devops-$(date +%Y%m%d%H%M%S)" >> $GITHUB_ENV

      - name: Deploy CloudFormation stack
        run: |
          aws cloudformation deploy \
            --template-file Iac/cloudFormationStack.yaml \
            --stack-name $RUN_ID \
            --parameter-overrides KeyName=AuroraBastionKey AvailabilityZones=us-east-2a,us-east-2b 

      - name: Get Aurora Secret ARN
        run: |
          secret_arn=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='SecretArn'].OutputValue" \
            --output text)
          echo "SECRET_ARN=$secret_arn" >> $GITHUB_ENV

      - name: Get Aurora endpoint
        run: |
          endpoint=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='ClusterEndpoint'].OutputValue" \
            --output text)
          echo "ENDPOINT_RDS_AURORA=$endpoint" >> $GITHUB_ENV

      - name: Get VPC 
        run: |
          vpcid=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='VpcId'].OutputValue" \
            --output text)
          echo "VPC_ID=$vpcid" >> $GITHUB_ENV

      - name: Get Security Group ID for Lambda Configuration
        run: |
          SecurityGroup=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='DBSecurityGroupLambda'].OutputValue" \
            --output text)
          echo "SECURITYGROUP=$SecurityGroup" >> $GITHUB_ENV

      - name: Get Bastion endpoint
        run: |
          ip_bastion=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='BastionPublicIP'].OutputValue" \
            --output text)
          echo "IP_BASTION=$ip_bastion" >> $GITHUB_ENV

      - name: Get Aurora password
        run: |
          password=$(aws secretsmanager get-secret-value \
            --secret-id $SECRET_ARN \
            --query 'SecretString' --output text | jq -r '.password')
          echo "PASSWORD=$password" >> $GITHUB_ENV

      - name: Get Aurora User
        run: |
          username=$(aws secretsmanager get-secret-value \
            --secret-id $SECRET_ARN \
            --query 'SecretString' --output text | jq -r '.username')
          echo "USERDB=$username" >> $GITHUB_ENV

      - name: Get DB NAME 
        run: |
          db_name=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='DATABASE'].OutputValue" \
            --output text)
          echo "DATABASE=$db_name" >> $GITHUB_ENV

      - name: Get DB NAME 
        run: |
          db_name=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='DBTABLE'].OutputValue" \
            --output text)
          echo "DBTABLE=$db_name" >> $GITHUB_ENV


      - name: Get SubnetsIds 
        run: |
          subnets=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='PrivateSubnets'].OutputValue" \
            --output text)
          echo "SUBNETIDS=$subnets" >> $GITHUB_ENV

      - name: Genera archivo de variables (ejemplo JSON)
        run: |
          echo "{
            \"VPC\": \"$VPC_ID\",
            \"HOST\": \"$ENDPOINT_RDS_AURORA\",
            \"USERDB\": \"$USERDB\",
            \"PASSWORD\": \"$PASSWORD\",
            \"IP_BASTION\": \"$IP_BASTION\",
            \"SECURITYGROUP\": \"$SECURITYGROUP\",
            \"DATABASE\": \"$DATABASE\",
            \"DBTABLE\": \"$DBTABLE\",
            \"SUBNETIDS\": \"$SUBNETIDS\",
            \"RUN_ID\": \"$RUN_ID\"
          }" > mensaje.json

      - name: Subir artifact
        uses: actions/upload-artifact@v4
        with:
          name: mensaje-params
          path: mensaje.json

      # - name: Tunnel SSH to Aurora (in background)
      #   run: |
      #     nohup ssh -i AuroraBastionKey.pem -N -L \
      #      3307:$ENDPOINT_RDS_AURORA:3306 \
      #       ubuntu@$IP_BASTION &

      # - name: Run SQL initialization script
      #   run: |
      #     mysql -h $ENDPOINT_RDS_AURORA -u $AURORA_USER -p $PASSWORD < SQL/user.sql

  deploy-lambda:
    runs-on: ubuntu-latest 
    needs: aws-setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }} 

      - name: Use Node.js 
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install TypeScript globally
        run: npm install -g typescript  

      - name : Install ESbuild globally
        run: npm install -g esbuild -D @types/aws-lambda

      - name : Install JS dependencies
        run: |
           npm install

      - name: Type Checking
        run: | 
          npm run type-check # Ej: tsc --noEmit

      - name: Zip Lambda function
        run: |
          mkdir lambdas-zipped
          cd lambdas
          for d in */ ; do
            ./${d}build.sh $d
          done


      - name: Create S3 bucket (if not exists) 
        env:
          AWS_S3_BUCKET: ${{ secrets.LAMBDA_ARTIFACT_BUCKET }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }} 
        run: |
          if aws s3api head-bucket --bucket "$AWS_S3_BUCKET" 2>/dev/null; then
            echo "Bucket $AWS_S3_BUCKET already exists."
          else
            aws s3api create-bucket --bucket "$AWS_S3_BUCKET" --region "$AWS_REGION" \
              --create-bucket-configuration LocationConstraint="$AWS_REGION"
            echo "Bucket $AWS_S3_BUCKET created."
          fi

      - name: Upload zip to S3
        uses: jakejarvis/s3-sync-action@v0.5.1
        with:
          args: --acl private
        env:
          AWS_S3_BUCKET: ${{ secrets.LAMBDA_ARTIFACT_BUCKET }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          SOURCE_DIR: ./lambdas-zipped          # Root (will look for lambda.zip)
          DEST_DIR: lambda-artifacts

      - name: Descargar artifact
        uses: actions/download-artifact@v4
        with:
          name: mensaje-params
          path: ./artifact

      - name: Leer archivo 
        run: | 
          cat ./artifact/mensaje.json

      - name: Leer archivo de variables
        run: |
          for key in $(jq -r 'keys[]' ./artifact/mensaje.json); do
              value=$(jq -r --arg k "$key" '.[$k]' ./artifact/mensaje.json)
            echo "$key=$value" >> $GITHUB_ENV
          done

            # Prueba: mostrar variables ya exportadas
            echo "HOST: $HOST"
            echo "USERDB: $USERDB"
            echo "PASSWORD: $PASSWORD"
            echo "DATABASE: $DATABASE"
            echo "DBTABLE: $DBTABLE"
            echo "SECURITYGROUP: $SECURITYGROUP"
            echo "SUBNETIDS: $SUBNETIDS"
            echo "RUN_ID: $RUN_ID"

      - name: Set Name Stacks Lambda
        run: | 
          echo "RUN_ID_LAMBDA=demo-stack-devops-lambda-$(date +%Y%m%d%H%M%S)" >> $GITHUB_ENV

      - name: Create Lambda functions and API GatewayId
        run: |
          aws cloudformation deploy \
            --template-file Iac/api.yaml \
            --stack-name $RUN_ID_LAMBDA \
            --parameter-overrides AWSS3BUCKET=${{ secrets.LAMBDA_ARTIFACT_BUCKET }} HOST=$HOST USERDB=$USERDB PASSWORD=$PASSWORD DATABASE=$DATABASE DBTABLE=$DBTABLE SECURITYGROUP=$SECURITYGROUP SUBNETIDS=$SUBNETIDS  \
            --capabilities CAPABILITY_NAMED_IAM

      - name: Get ApiGatewat
        run: |
          apiurl=$(aws cloudformation describe-stacks \
            --stack-name $RUN_ID \
            --query "Stacks[0].Outputs[?OutputKey=='APIURL'].OutputValue" \
            --output text)
          echo "APIURL=$apiurl" >> $GITHUB_ENV

      - name: Genera archivo de variables (ejemplo JSON)
        run: |
          echo "{
            \"VPC\": \"$VPC_ID\",
            \"HOST\": \"$ENDPOINT_RDS_AURORA\",
            \"USERDB\": \"$USERDB\",
            \"PASSWORD\": \"$PASSWORD\",
            \"IP_BASTION\": \"$IP_BASTION\",
            \"SECURITYGROUP\": \"$SECURITYGROUP\",
            \"DATABASE\": \"$DATABASE\",
            \"DBTABLE\": \"$DBTABLE\",
            \"SUBNETIDS\": \"$SUBNETIDS\",
            \"RUN_ID\": \"$RUN_ID\",
            \"RUN_ID_LAMBDA\": \"$RUN_ID_LAMBDA\",
            \"APIURL\": \"$APIURL\"
          }" > mensaje-two.json

      - name: Subir artifact
        uses: actions/upload-artifact@v4
        with:
          name: mensaje-params-two
          path: mensaje-two.json

      - name: Invoke Lambda function Creation DB
        run: |
          cd lambdas/DataBaseCreation &&
          aws lambda invoke \
          --function-name DataBaseCreation \
          --cli-binary-format raw-in-base64-out \
          --payload "$(jq -n --arg sqlString "$(cat sql/create.sql)" '{ sqlString: $sqlString }')" \
          resultado.json &&
          cat resultado.json
          
      - name: Invoke Lamnbda function Check DB
        run : |
          aws lambda invoke \
          --function-name CheckDataBase  \
          resultado.json &&
          STATUS=$(cat resultado.json | jq '.statusCode')
          BODY=$(cat resultado.json | jq -r '.body')

          if [ "$STATUS" -eq 200 ] && echo "$BODY" | grep -q "now"; then
            echo "Test exitoso"
          else
            echo "Test fallido"
          fi

  test-lambdas:
    runs-on: ubuntu-latest 
    needs: deploy-lambda
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }} 


      - name: Descargar artifact
        uses: actions/download-artifact@v4
        with:
          name: mensaje-params-two
          path: ./artifact

      - name: Leer archivo 
        run: | 
          cat ./artifact/mensaje-two.json

      - name: Leer archivo de variables
        run: |
          for key in $(jq -r 'keys[]' ./artifact/mensaje-two.json); do
              value=$(jq -r --arg k "$key" '.[$k]' ./artifact/mensaje-two.json)
            echo "$key=$value" >> $GITHUB_ENV
          done

            # Prueba: mostrar variables ya exportadas
            echo "HOST: $HOST"
            echo "USERDB: $USERDB"
            echo "PASSWORD: $PASSWORD"
            echo "DATABASE: $DATABASE"
            echo "DBTABLE: $DBTABLE"
            echo "SECURITYGROUP: $SECURITYGROUP"
            echo "SUBNETIDS: $SUBNETIDS"
            echo "RUN_ID: $RUN_ID"
            echo "RUN_ID_LAMBDA: $RUN_ID_LAMBDA"
            echo "APIURL: $APIURL"

      - name: List archivos y directorio
        run: |
          pwd
          ls -l
          ls -l lambda-tests/

      - name: Ejecuta tests de Lambda desde archivos
        run: |
          for testfile in lambda-tests/*.json; do
            FUNC_NAME=$(basename "$testfile" .json)
            echo "Probando función $FUNC_NAME con payload de $testfile"
            aws lambda invoke \
              --cli-binary-format raw-in-base64-out \
              --function-name "$FUNC_NAME" \
              --payload file://"$testfile" \
              "output_$FUNC_NAME.json" || echo "Error invocando $FUNC_NAME"
            echo "Output de $FUNC_NAME:"
            if test -f "output_$FUNC_NAME.json"; then
              cat "output_$FUNC_NAME.json"
            else
              echo "No output file generated."
            fi
            echo ""
          done

  test-api:

    runs-on: ubuntu-latest
    needs: test-lambdas
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }} 

      - name: Descargar artifact
        uses: actions/download-artifact@v4
        with:
          name: mensaje-params-two
          path: ./artifact

      - name: Leer archivo 
        run: | 
          cat ./artifact/mensaje-two.json

      - name: Leer archivo de variables
        run: |
          for key in $(jq -r 'keys[]' ./artifact/mensaje-two.json); do
              value=$(jq -r --arg k "$key" '.[$k]' ./artifact/mensaje-two.json)
            echo "$key=$value" >> $GITHUB_ENV
          done

            # Prueba: mostrar variables ya exportadas
            echo "HOST: $HOST"
            echo "USERDB: $USERDB"
            echo "PASSWORD: $PASSWORD"
            echo "DATABASE: $DATABASE"
            echo "DBTABLE: $DBTABLE"
            echo "SECURITYGROUP: $SECURITYGROUP"
            echo "SUBNETIDS: $SUBNETIDS"
            echo "RUN_ID: $RUN_ID"
            echo "RUN_ID_LAMBDA: $RUN_ID_LAMBDA"
            echo "APIURL: $APIURL"

      - name: Ejecuta tests de la API (curl) desde archivos
        env:
          BASE_URL: ${{APIURL}}
        run: |
          for testfile in api-tests/*.json; do
            TEST=$(cat "$testfile")
            ENDPOINT=$(echo "$TEST" | jq -r .path)
            METHOD=$(echo "$TEST" | jq -r .method)
            BODY=$(echo "$TEST" | jq -c .body)
            OUT_FILE="output_$(basename "$testfile" .json).txt"
            
            echo "Test: $testfile ($METHOD $ENDPOINT)"
            
            if [ "$BODY" != "null" ]; then
              curl -X "$METHOD" "$BASE_URL$ENDPOINT" -H "Content-Type: application/json" -d "$BODY" -s -w "\n" > "$OUT_FILE"
            else
              curl -X "$METHOD" "$BASE_URL$ENDPOINT" -s -w "\n" > "$OUT_FILE"
            fi

            echo "Respuesta:"
            cat "$OUT_FILE"
            echo ""
          done

  destroy:
    runs-on: ubuntu-latest 
    needs: test-api
    if: github.branches == 'develop'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }} 


      - name: Leer archivo 
        run: | 
          cat ./artifact/mensaje-two.json

      - name: Leer archivo de variables
        run: |
          for key in $(jq -r 'keys[]' ./artifact/mensaje-two.json); do
              value=$(jq -r --arg k "$key" '.[$k]' ./artifact/mensaje-two.json)
            echo "$key=$value" >> $GITHUB_ENV
          done

            # Prueba: mostrar variables ya exportadas
            echo "HOST: $HOST"
            echo "USERDB: $USERDB"
            echo "PASSWORD: $PASSWORD"
            echo "DATABASE: $DATABASE"
            echo "DBTABLE: $DBTABLE"
            echo "SECURITYGROUP: $SECURITYGROUP"
            echo "SUBNETIDS: $SUBNETIDS"
            echo "RUN_ID: $RUN_ID"
            echo "RUN_ID_LAMBDA: $RUN_ID_LAMBDA"
            echo "APIURL: $APIURL"

      - name: Delete Lambda and API Stack
        run: |
          aws cloudformation delete-stack --stack-name $RUN_ID_LAMBDA

      - name: Delete Main Stack
        run: |
          aws cloudformation delete-stack --stack-name $RUN_ID
          
      - name: Wait for stacks to be deleted
        run: |
          aws cloudformation wait stack-delete-complete --stack-name $RUN_ID_LAMBDA
          aws cloudformation wait stack-delete-complete --stack-name $RUN_ID
          
      - name: Confirm deletion
        run: |
          echo "Stacks $RUN_ID_LAMBDA and $RUN_ID have been deleted."

      - name: Crear Pull Request de develop a main
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: main
          base: main
          title: "Merge develop into main automáticamente"
          body: "Este PR fue creado por GitHub Actions luego de pasar todos los tests en develop."

      - name: Obtener número de PR
        run: echo "PR_NUMBER=${{ steps.crear_pr.outputs.pull-request-number }}" >> $GITHUB_ENV

      - name: Hacer automerge del PR a main
        uses: peter-evans/merge-pull-request@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          pull-request: ${{ env.PR_NUMBER }}
          merge-method: squash
          commit-title: "Merge automático develop -> main"
          commit-message: "Fusionado automáticamente tras CI en develop"